"""OpenAlex API
OpenAlex is a fully open catalog of the global research system. It's named after the ancient Library of Alexandria and made by the nonprofit OurResearch.  The API is the primary way to get OpenAlex data. It's free and requires no authentication. The daily limit for API calls is 100,000 requests per user per day.  For best performance, add your email to all API requests to join the polite pool using either: - The `mailto` query parameter (e.g., `mailto=you@example.com`) - The `User-Agent` header with mailto (e.g., `User-Agent: MyApp/1.0 (mailto:you@example.com)`)  Premium users get an API key which grants higher API limits and access to special filters.
OpenAPI spec version: 1.0.0
Generated by: https://github.com/swagger-api/swagger-codegen.git.
"""

import pprint

import six


class MeshTag:
    """NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        "descriptor_ui": "str",
        "descriptor_name": "str",
        "qualifier_ui": "str",
        "qualifier_name": "str",
        "is_major_topic": "bool",
    }
    attribute_map = {
        "descriptor_ui": "descriptor_ui",
        "descriptor_name": "descriptor_name",
        "qualifier_ui": "qualifier_ui",
        "qualifier_name": "qualifier_name",
        "is_major_topic": "is_major_topic",
    }

    def __init__(
        self,
        descriptor_ui=None,
        descriptor_name=None,
        qualifier_ui=None,
        qualifier_name=None,
        is_major_topic=None,
    ):
        """MeshTag - a model defined in Swagger."""
        self._descriptor_ui = None
        self._descriptor_name = None
        self._qualifier_ui = None
        self._qualifier_name = None
        self._is_major_topic = None
        self.discriminator = None
        self.descriptor_ui = descriptor_ui
        self.descriptor_name = descriptor_name
        if qualifier_ui is not None:
            self.qualifier_ui = qualifier_ui
        if qualifier_name is not None:
            self.qualifier_name = qualifier_name
        self.is_major_topic = is_major_topic

    @property
    def descriptor_ui(self):
        """Gets the descriptor_ui of this MeshTag.
        MeSH descriptor unique identifier
        :return: The descriptor_ui of this MeshTag.
        :rtype: str.
        """
        return self._descriptor_ui

    @descriptor_ui.setter
    def descriptor_ui(self, descriptor_ui):
        """Sets the descriptor_ui of this MeshTag.
        MeSH descriptor unique identifier
        :param descriptor_ui: The descriptor_ui of this MeshTag.
        :type: str.
        """
        if descriptor_ui is None:
            raise ValueError("Invalid value for `descriptor_ui`, must not be `None`")
        self._descriptor_ui = descriptor_ui

    @property
    def descriptor_name(self):
        """Gets the descriptor_name of this MeshTag.
        MeSH descriptor name
        :return: The descriptor_name of this MeshTag.
        :rtype: str.
        """
        return self._descriptor_name

    @descriptor_name.setter
    def descriptor_name(self, descriptor_name):
        """Sets the descriptor_name of this MeshTag.
        MeSH descriptor name
        :param descriptor_name: The descriptor_name of this MeshTag.
        :type: str.
        """
        if descriptor_name is None:
            raise ValueError("Invalid value for `descriptor_name`, must not be `None`")
        self._descriptor_name = descriptor_name

    @property
    def qualifier_ui(self):
        """Gets the qualifier_ui of this MeshTag.
        MeSH qualifier unique identifier
        :return: The qualifier_ui of this MeshTag.
        :rtype: str.
        """
        return self._qualifier_ui

    @qualifier_ui.setter
    def qualifier_ui(self, qualifier_ui):
        """Sets the qualifier_ui of this MeshTag.
        MeSH qualifier unique identifier
        :param qualifier_ui: The qualifier_ui of this MeshTag.
        :type: str.
        """
        self._qualifier_ui = qualifier_ui

    @property
    def qualifier_name(self):
        """Gets the qualifier_name of this MeshTag.
        MeSH qualifier name
        :return: The qualifier_name of this MeshTag.
        :rtype: str.
        """
        return self._qualifier_name

    @qualifier_name.setter
    def qualifier_name(self, qualifier_name):
        """Sets the qualifier_name of this MeshTag.
        MeSH qualifier name
        :param qualifier_name: The qualifier_name of this MeshTag.
        :type: str.
        """
        self._qualifier_name = qualifier_name

    @property
    def is_major_topic(self):
        """Gets the is_major_topic of this MeshTag.
        Whether this is a major topic
        :return: The is_major_topic of this MeshTag.
        :rtype: bool.
        """
        return self._is_major_topic

    @is_major_topic.setter
    def is_major_topic(self, is_major_topic):
        """Sets the is_major_topic of this MeshTag.
        Whether this is a major topic
        :param is_major_topic: The is_major_topic of this MeshTag.
        :type: bool.
        """
        if is_major_topic is None:
            raise ValueError("Invalid value for `is_major_topic`, must not be `None`")
        self._is_major_topic = is_major_topic

    def to_dict(self):
        """Returns the model properties as a dict."""
        result = {}
        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = [x.to_dict() if hasattr(x, "to_dict") else x for x in value]
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(
                    map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict")
                        else item,
                        value.items(),
                    )
                )
            else:
                result[attr] = value
        if issubclass(MeshTag, dict):
            for key, value in self.items():
                result[key] = value
        return result

    def to_str(self):
        """Returns the string representation of the model."""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`."""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal."""
        if not isinstance(other, MeshTag):
            return False
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal."""
        return not self == other
